<!DOCTYPE html>
<html>
<head>
<title>developers-guide-eyex-plugin-for-ue4</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
</head>
<body>
<h2 id="-tobii-tech-images-tobii_tech_logo_royal_small-png-"><img src="images/Tobii_Tech_Logo_Royal_small.png" alt="Tobii Tech"></h2>
<h1 id="developer-s-guide-tobii-eyex-sdk-for-unreal-engine-4">Developer&#39;s Guide - Tobii EyeX SDK for Unreal Engine 4</h1>
<hr>
<p><strong>The Tobii EyeX Software Development Kit (SDK) for Unreal Engine 4 contains everything you need for building games using the Tobii EyeX Engine API and the Tobii EyeX plugin for Unreal Engine 4.</strong></p>
<hr>
<p>Last updated: January 22, 2016</p>
<p>Images © 2016 Tobii AB (publ) - All rights reserved. Tobii and the Tobii logos are either registered trademarks or trademarks of Tobii in the United States and/or other countries.<br><a href="http://www.tobii.com">www.tobii.com</a></p>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#introduction">Introduction</a></li><li><a href="#getting-started">Getting started</a><ul>
<li><a href="#how-to-set-up-the-development-environment">How to set up the development environment</a></li><li><a href="#sample-scenes">Sample scenes</a></li><li><a href="#where-to-go-from-here">Where to go from here</a></li></ul>
</li><li><a href="#your-game-and-the-tobii-eyex-environment">Your game and the Tobii EyeX environment</a></li><li><a href="#overview-of-the-eyex-engine-api">Overview of the EyeX Engine API</a><ul>
<li><a href="#the-gaze-point-data-stream">The Gaze point data stream</a></li><li><a href="#the-eye-position-data-stream">The Eye position data stream</a></li><li><a href="#the-fixation-data-stream">The Fixation data stream</a></li><li><a href="#the-user-presence-state">The User presence state</a></li></ul>
</li><li><a href="#using-the-eyex-plugin-for-unreal-engine">Using the EyeX Plugin for Unreal Engine</a><ul>
<li><a href="#using-eyex-engine-data-streams-and-states">Using EyeX Engine data streams and states</a></li><li><a href="#detecting-actors-with-eye-gaze-interaction">Detecting actors with eye-gaze interaction </a><ul>
<li><a href="#configurable-detection-strategies">Configurable detection strategies</a></li><li><a href="#using-eye-gaze-interaction-in-blueprints">Using eye-gaze interaction in blueprints</a></li></ul>
</li><li><a href="#mouse-emulation">Mouse emulation</a></li><li><a href="#c-code-sample-gaze-point-data">C++ code sample: Gaze Point data</a></li><li><a href="#blueprint-sample-gaze-point-data">Blueprint sample: Gaze Point data</a></li><li><a href="#blueprint-sample-a-cube-which-spins-when-the-player-is-looking-at-it">Blueprint sample: a cube which spins when the player is looking at it</a></li></ul>
</li><li><a href="#building-and-distributing-your-game">Building and distributing your game</a></li></ul>
<h2 id="introduction">Introduction</h2>
<p>Have you ever wanted to create a game that the player can interact with using her eyes? The EyeX Plugin for Unreal Engine bridges the gap between the Unreal Engine development environment and the Tobii EyeX API and lets you do just that.</p>
<p>The plugin can be inserted into any game built with the Unreal Engine 4.6 or higher and used from both blueprints and C++ code.</p>
<p>Because the plugin depends on the Tobii EyeX Engine, it will only work properly on platforms where the EyeX Engine is supported: currently Windows 7 and later. The plugin includes a mouse emulation function that can be used to do some limited development and testing on other platforms as well.</p>
<p>The EyeX Plugin for Unreal Engine is provided on GitHub under a quite permissive open-source license. You will also need the EyeX client library to use the plugin. It can be downloaded from Tobii free of charge, and it has a permissive (but not open source) license agreement too. Make sure to read the license agreement because it’s not the same as for the plugin itself.</p>
<p><em>Note. Tobii provides EyeX SDKs for several other development environments in addition to the Unreal Engine. They are all available for download from the</em> <a href="http://developer.tobii.com">Tobii Developer Zone</a>.</p>
<p><a href="#table-of-contents">&uarr; Back to Table of Contents</a></p>
<h2 id="getting-started">Getting started</h2>
<p>You will need:</p>
<ul>
<li>The Unreal Engine version 4.6 or later from Epic. You may either download and run the UE installer, or build it yourself from source if you have access to the UE source on GitHub.</li><li>The Tobii EyeX software bundle (can be downloaded here: <a href="http://www.tobii.com/eyex-setup">www.tobii.com/eyex-setup</a>) and an EyeX Controller (can be bought here: <a href="http://www.tobii.com/xperience">www.tobii.com/xperience</a>) or other compatible eye tracker. The SteelSeries Sentry works just as well, for example. <img src="images/TobiiTech_EyeX_Controller_sm.png" alt=""></li><li>The Tobii EyeX Plugin for Unreal Engine. Download it from the EyeXforUE4 project on GitHub.</li><li>Microsoft Visual Studio 2013/2015 (Unreal Engine 4.10 and higher requires VS2015).</li></ul>
<p><a href="#table-of-contents">&uarr; Back to Table of Contents</a></p>
<h2 id="how-to-set-up-the-development-environment">How to set up the development environment</h2>
<p>Follow the steps in the README.md file carefully to set up the development environment for EyeX.</p>
<p>After you have completed the setup you should have a working sample “game” with a couple of scenes that demonstrate various usages of the eye tracking data. </p>
<p>You should also be able to grab the Plugins folder from the sample game and drop it into your own game. And that’s when the real fun starts!</p>
<p><a href="#table-of-contents">&uarr; Back to Table of Contents</a></p>
<h2 id="sample-scenes">Sample scenes</h2>
<p>The EyeX Plugin for Unreal Engine package includes not only the plugin itself but also a sample project with a few sample scenes (in the form of levels/maps) that demonstrate how the eye tracking data can be used in a game.</p>
<p>All samples are implemented in the form of blueprints.</p>
<p><em>Note. The graphics and gameplay in the sample scenes have been deliberately kept to a minimum so as not to get in the way of the code.</em></p>
<h4 id="sample-scene-gaze-interaction">Sample scene: Gaze Interaction</h4>
<p>This scene contains a few objects that respond differently to the player’s eye-gaze: the sphere spins around, the rock grows, and the cube turns on a light source when looked at.</p>
<p>Looking at the blueprint you will find that the sphere and the rock trigger their actions using the HasGazeFocus method, while the cube uses the GotGazeFocus/LostGazeFocus events.</p>
<p>Another interesting thing to do in this scene is to select the player controller actor while the level is running in the editor and enable the EyeX/VisualizeDetection property. Doing that will let you see how the hit testing is performed. You can also try different detection modes.</p>
<h4 id="sample-scene-adaptive-depth-of-field">Sample scene: Adaptive Depth of Field</h4>
<p>This scene contains a couple of objects tossed out at different distances. When you focus on one of them, the rendering updates so that objects that are out of focus (due to the limited depth-of-field) are blurred. This means that the view won’t be perfectly sharp everywhere at the same time. That could have some really interesting uses in a FPS game.</p>
<h4 id="sample-scene-eye-position">Sample scene: Eye Position</h4>
<p>This scene visualizes the player’s eyes and the gaze point in 3D. It gives an idea of how the eye positions data stream behaves.</p>
<h4 id="sample-scene-user-presence">Sample scene: User Presence</h4>
<p>In this scene the screen is dimmed when no player is present in front of the screen.</p>
<h4 id="sample-scene-fixations">Sample scene: Fixations</h4>
<p>This scene shows how the fixation detection works: it’s a static scene and the fixations are visualized on top.<br>Fixations are points where the gaze lingers to focus on something. The visualization displays the last few fixations as orange circles and the ongoing fixation (if any) as a gray circle.</p>
<h4 id="sample-scene-gaze-point">Sample scene: Gaze Point</h4>
<p>This is a scene where the player’s gaze point is visualized on top of the viewport. You can try both the unfiltered and the lightly filtered alternatives and compare them to each other.</p>
<p><a href="#table-of-contents">&uarr; Back to Table of Contents</a></p>
<h3 id="where-to-go-from-here">Where to go from here</h3>
<p>We recommend that you browse through the rest of this Developer’s Guide, because it will give you a big picture view of the EyeX Engine and its API. Knowing what the engine can do for you, and how the pieces fit together, will surely be helpful as you move on to create your game.</p>
<p>After that you should be ready to create some eye-gaze interaction yourself! Just remember that the Tobii Developer Zone is there for you if you need inspiration or if you get stuck.</p>
<p><a href="#table-of-contents">&uarr; Back to Table of Contents</a> </p>
<h2 id="your-game-and-the-tobii-eyex-environment">Your game and the Tobii EyeX environment</h2>
<p>The figure below gives an overview of the hardware and software components that work together to create the Tobii Eye Experience. By using the EyeX plugin in your game, you can make it possible for the player to interact with the game using her eyes!</p>
<p><img src="images/devguide-your-game-and-eyex.png" alt=""><br><em>Figure 1 Your game and Tobii EyeX environment. The game is running on the computer screen on the left-hand side. An EyeX Controller is mounted on the screen and is detecting the player’s eye-gaze. The diagram on the right-hand side shows the software running on the computer. The game makes use of the EyeX Engine and Controller through the EyeX Plugin.</em></p>
<p>The <strong>EyeX Controller</strong> is a device which can determine what you’re looking at. It is mounted on the bottom of the computer screen and attached to the computer with a USB 3.0 cable.</p>
<p>The <strong>EyeX Engine</strong> takes the data from the EyeX Controller or other compatible device, processes the data, and makes it available to your game and other applications through an API. The EyeX Engine also takes care of all the necessary groundwork when it comes to eye tracker hardware configuration, user calibration, and so on.</p>
<p>The <strong>EyeX Plugin for Unreal Engine</strong> adapts the EyeX API so that it can be used easily in games built using the Unreal Engine.<br>EyeX Interaction is a way of interacting with the computer in a natural and effortless way based on where you look. This ranges from your computer simply being aware of your presence all the way to clicking and scrolling in apps or games that have implemented EyeX Engine interactions. The box labeled EyeX Interaction in the diagram represents the software that enables this kind of interaction in the Windows environment. It is passive while your game is running.</p>
<p><a href="#table-of-contents">&uarr; Back to Table of Contents</a></p>
<h2 id="overview-of-the-eyex-engine-api">Overview of the EyeX Engine API</h2>
<p>The figure below presents an overview of what the EyeX Engine API offers. The EyeX Plugin for Unreal Engine currently does not cover the whole API: the parts that handle regions have been left out because they are not straightforward to implement in a 3D environment. But the plugin does offer an alternative for gaze-aware regions, see the section Detecting actors with eye-gaze interaction for more information.</p>
<p><img src="images/devguide-eyex-api-overview.png" alt=""><br><em>Figure 2 A somewhat simplified view of what the EyeX Engine API can do for you.</em></p>
<p><a href="#table-of-contents">&uarr; Back to Table of Contents</a></p>
<h3 id="the-gaze-point-data-stream">The Gaze point data stream</h3>
<p>The Gaze point data stream represents the user’s gaze point on the screen. The unfiltered data stream produces a new data point whenever the engine receives a valid eye-gaze data point from the eye tracker. No statements are made regarding the frame rate; you get what you get.</p>
<p><img src="images/devguide-eyex-api-overview-gaze-point.png" alt=""><br><em>Figure 3: The gaze point is an inherently noisy signal. The orange dots on this screenshot represent the user’s gaze point during a fraction of a second. Filtering makes the point cloud shrink towards its center, but also respond slower to rapid eye movements.</em></p>
<p>The gaze point is given as a single point. If the user has chosen to track a specific eye, then it’s the gaze point from that eye. Otherwise the point is taken to be the average from both eyes. </p>
<p>Because the gaze point is an intrinsically noisy signal, the Gaze point data stream provides a selection of filters that can be used to stabilize the signal. As usual when it comes to filtering, there is a trade-off between stability and responsiveness, so there cannot be a single filter that is the best choice for all applications, but the Lightly filtered option is a reasonable default and works in most cases. The available filters are: </p>
<ul>
<li><strong>Lightly filtered</strong>: an adaptive filter which is weighted based on both the age of the data points and the velocity of the eye movements. This filter is designed to remove noise while at the same time being responsive to quick eye movements. </li><li><strong>Unfiltered</strong>: no filtering performed by the engine. (Except for the removal of invalid data points and the averaging of the gaze points from both eyes.) </li></ul>
<p><a href="#table-of-contents">&uarr; Back to Table of Contents</a></p>
<h3 id="the-eye-position-data-stream">The Eye position data stream</h3>
<p>The Eye position data stream provides the positions of the user’s eyes in three-dimensional space. This data stream can be used, for example, to control the camera perspective. </p>
<p>This data stream produces a new value whenever the engine receives a valid sample from the eye tracker, and no statements are made about the frame rate, just as for the Gaze point data stream. The eye positions are given for the left and right eyes individually. </p>
<p>The Eye position data stream does not offer any filtering options at this time.</p>
<h5 id="good-to-know-about-the-eye-position-data-from-the-eyex-controller">Good to know about the Eye position data from the EyeX Controller</h5>
<p>There are some limitations to the smoothness of the eye position data stream from the EyeX Controller eye tracking device. Any user experience based on the eye position data stream should be designed with these limitations in mind.</p>
<p>First, the distance of the eyes to the eye tracker is not updated while the user is moving her head towards or away from the controller. This means that the eye position will follow smoothly only when moving the eyes and the head at a roughly fixed distance from the screen, like when you are leaning from side to side. The reported eye position will catch up with a jump when the head movement has stopped.</p>
<p>Second, the calculated distance to the eyes may have a user-dependent offset error. So use it only for relative, not absolute positioning – which is a good idea anyway since users will choose to sit at different distances from the screen. </p>
<p><a href="#table-of-contents">&uarr; Back to Table of Contents</a></p>
<h3 id="the-fixation-data-stream">The Fixation data stream</h3>
<p>The Fixation data stream provides information about when the user is fixating her eyes at a single location. This data stream can be used to get an understanding of where the user’s attention is. In most cases, when a person is fixating at something for a long time, this means that the person’s brain is processing the information at the point of fixation. If you want to know more about fixations, the Internet is your friend. </p>
<p>The fixation data stream can be accessed through two functions: one getting the ongoing fixation, if any, and one getting the last finished fixation. Each fixation is presented as a gaze point, a start time, and the duration. </p>
<p>There are two different fixation detection modes to choose from:</p>
<ul>
<li><strong>Sensitive</strong>: will result in many fixations, sometimes very close and in quick succession. </li><li><strong>Slow</strong>: will result in fairly stable fixations but may leave somewhat late. </li></ul>
<p><a href="#table-of-contents">&uarr; Back to Table of Contents</a></p>
<h3 id="the-user-presence-state">The User presence state</h3>
<p>The User presence state provides information about whether there is currently a user in front of the screen or not. The state can be “Present”, “Not Present” or “Unknown”. The “Unknown” state occurs when there is no information available, for example when there is no eye tracker connected to the computer.</p>
<p><a href="#table-of-contents">&uarr; Back to Table of Contents</a></p>
<h2 id="using-the-eyex-plugin-for-unreal-engine">Using the EyeX Plugin for Unreal Engine</h2>
<p>The EyeX Plugin for Unreal Engine wraps the functionality of the EyeX Engine C API and adapts it for use with Unreal Engine. What does that mean? Well, for one thing: whereas the EyeX Engine API is multi-threaded and fully asynchronous, the Unreal Engine environment is frame-based (that is, it is updated in discrete “ticks” or frames) and essentially single-threaded. Another thing is that you need to add special markup to functions or data in order to use them from blueprints. The EyeX Plugin for Unreal Engine does these two things and a few other things as well.</p>
<p><em>Note. If you want to know how things work under the hood, or if you want to do advanced stuffz that cannot be done with this plugin, then feel free to check out the header documentation for the C API, because this guide doesn’t cover that API. If you’d rather not, like most people, then you can safely ignore it.</em></p>
<p><a href="#table-of-contents">&uarr; Back to Table of Contents</a></p>
<h3 id="using-eyex-engine-data-streams-and-states">Using EyeX Engine data streams and states</h3>
<p>All relevant EyeX engine states and data streams can be accessed through accessor (getter) functions, both from blueprints and from C++ code. These functions will always give you the most recent data point of a data stream, or the current value of an engine state.</p>
<p>If you use blueprints, you will find these functions in the EyeX blueprint function library. If you use C++, you will find them in the plugin module interface class: IEyeXPlugin.</p>
<p>In addition to the EyeX Engine data streams and states, there are also some functions for getting derived data that can be useful in gaming scenarios, such as the head rotation (yaw and roll) derived from the eye positions.</p>
<p>Data streams are not subscribed to by default. The subscription is set up the first time you use the accessor function (or the accessor function for a derived value), which means that the EyeX Engine will start sending data at that point. This means that you will never receive a valid value on the first call to the accessor function.</p>
<p>The EyeX Engine states exposed through the plugin API are updated automatically. You can always read from them and they will reflect the most recent value provided by the engine. If the connection to the engine is lost they will be reset to invalid.</p>
<p>The special template class TEyeXMaybeValue is used for values that may or may not be known. For example, the GetScreenBounds method returns a value of type TEyeXMaybeValue<FEyeXScreenBounds>. If no connection to the EyeX Engine has been established, or the EyeX Engine isn’t set up properly, then the returned value will have its bHasValue flag set to false.</p>
<p><a href="#table-of-contents">&uarr; Back to Table of Contents</a></p>
<h3 id="detecting-actors-with-eye-gaze-interaction">Detecting actors with eye-gaze interaction</h3>
<p>Suppose you have some actors in your scene that should respond to the player’s eye-gaze somehow. The EyeX Plugin for Unreal Engine provides a player controller/actor base class combo that you can use to do exactly that.</p>
<p>The AEyeXPlayerController class derives from the APlayerController class. It is always on the lookout for eye-gaze interactable actors in the viewport: each tick it will try to read the player’s gaze point and find out which actor the player is looking at. It will only consider actors derived from the AEyeXActorBase.</p>
<p><a href="#table-of-contents">&uarr; Back to Table of Contents</a></p>
<h4 id="configurable-detection-strategies">Configurable detection strategies</h4>
<p>The EyeX player controller can be configured to use one of several possible detection strategies to decide which actor the player is currently looking at. Some are fast but not very sensitive whereas others are slow but very accurate. The default strategy works in most cases, but if you should find that you need something faster because you have a busy scene, or something more accurate because the eye-gaze interaction is a central part of the gameplay, then we encourage you to experiment. The player controller class has a setting for debug visualization that will let you see the gaze point and the detection results in real time when enabled. (This feature is disabled when building for shipping.) </p>
<table>
<thead>
<tr>
<th><strong>Detection strategy</strong></th>
<th><strong>Description</strong></th>
<th><strong>Pros and cons</strong> </th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>Detection is disabled.</td>
<td>(n/a)</td>
</tr>
<tr>
<td>Line Trace</td>
<td>Performs a basic line trace hit testing starting from the gaze point.</td>
<td>Fast, but the actors may have to be surrounded in collision volumes in order to be detected. </td>
</tr>
<tr>
<td>Boxed Line Trace</td>
<td>Starts with a basic line trace. If no actors are found, does additional line traces in a box shape around the gaze point.</td>
<td>Pretty fast and with a higher detection success rate than a basic line trace.</td>
</tr>
<tr>
<td>Sweep</td>
<td>Performs hit testing with a sphere swept from the gaze point into the scene. The sweep is performed in segments where the size of the sphere is adjusted in each segment to keep it roughly at a fixed size in 3D world coordinates.</td>
<td>High detection success rate, but more expensive (slow) than the line traces. </td>
</tr>
<tr>
<td>Frustum Intersection</td>
<td>Calculates a view frustum defined by a box shape around the gaze point in screen space and checks for any actors intersecting with the frustum.</td>
<td>Very accurate, but can be expensive (slow) if the scene contains many EyeXActors with a lot of vertices.</td>
</tr>
</tbody>
</table>
<p>The AEyeXActorBase class has no behavior of its own, but it does have some properties like cutoff distances and dwell times that affect the sensitivity of the detection.</p>
<p><a href="#table-of-contents">&uarr; Back to Table of Contents</a></p>
<h4 id="using-eye-gaze-interaction-in-blueprints">Using eye-gaze interaction in blueprints</h4>
<p>To implement eye-gaze interaction with blueprints you need to have a player controller blueprint that inherits from EyeXPlayerController, and create actor blueprints that inherits from EyeXActorBase for every actor you want to interact with in the scene. Make sure the EyeX based player controller is set up as the selected player controller in the game’s default or level game mode.</p>
<p>The EyeXPlayerController keeps track of which actor the player is currently looking at, if any. An actor deriving from EyeXActorBase can get information about if the player is currently looking at it in two ways:</p>
<ul>
<li>By listening to the EyeX player controller events GotGazeFocus and LostGazeFocus.</li><li>By listening to the Tick event and using the HasGazeFocus function which returns true or false depending on if the player is looking at the actor or not.</li></ul>
<p>To use any of these events or function in a blueprint, right click in the blueprint graph and type “EyeX” to filter out the eye tracking blueprint nodes.</p>
<p>The detection strategy used by the EyeXPlayerController based blueprint can be changed in the Defaults tab in the blueprint editor.</p>
<p>For examples on how to use eye-gaze interaction in blueprints, see section Blueprint sample: a cube which spins when the player is looking at it, and the implementation of the sample scenes included in the EyeXSamples project.</p>
<p><a href="#table-of-contents">&uarr; Back to Table of Contents</a></p>
<h3 id="mouse-emulation">Mouse emulation</h3>
<p>The EyeX Plugin for Unreal Engine includes a mouse emulation function which can be useful not only for testing/troubleshooting eye-gaze interaction, but also for game development on platforms where EyeX isn’t available. When enabled, the mouse emulation function will let you emulate the gaze point using the mouse pointer.</p>
<p>The sample project has a key binding set up to toggle mouse emulation with the F10 key. You can do the same in your own game if you wish.</p>
<p><a href="#table-of-contents">&uarr; Back to Table of Contents</a></p>
<h3 id="c-code-sample-gaze-point-data">C++ code sample: Gaze Point data</h3>
<p>The arguably simplest use case in the EyeX environment is to read the player’s current gaze point and use it to make something happen, like popping balloons or controlling the mix volumes of some audio sources in the scene. Here is how to do that in C++ code. </p>
<pre><code class="lang-cpp">#include &lt;IEyeXPlugin.h&gt;

void SomeClass::SomeMethod() 
{ 
    if (!IEyeXPlugin::IsAvailable()) 
    { 
        return; 
    }
    IEyeXPlugin&amp; Plugin = IEyeXPlugin::Get(); 
    auto GazePoint = Plugin.GetGazePoint(EEyeXGazePointDataMode::LightlyFiltered); 
    // ... etc ...
}
</code></pre>
<p><em>Figure 4: Code sample demonstrating how to access the plugin and the lightly filtered gaze point data stream from C++.</em></p>
<p><a href="#table-of-contents">&uarr; Back to Table of Contents</a></p>
<h3 id="blueprint-sample-gaze-point-data">Blueprint sample: Gaze Point data</h3>
<p>This blueprint sample walkthrough will show you have to retrieve and use gaze point data in a blueprint graph.</p>
<p>Make sure you have a game project set up with the Tobii EyeX plugin. Build a Development Editor and create an empty level.</p>
<h4 id="step-1-create-the-necessary-blueprints">Step 1: Create the necessary blueprints</h4>
<p>You will need two blueprints for this sample: a HUD blueprint and a game mode blueprint. The HUD blueprint will draw a small rectangle on the screen at the gaze point, and the game mode blueprint is necessary only to specify which HUD blueprint to use.<br>Create the two blueprints and name them like this:</p>
<ul>
<li>BP_GazeIntoTheVoidHUD, based on HUD (type “hud” in the All Classes search box)</li><li>BP_GazeIntoTheVoidGameMode, based on GameMode</li></ul>
<h5 id="step-2-set-up-the-game-mode-to-use-the-specific-hud-blueprint">Step 2: Set up the game mode to use the specific HUD blueprint</h5>
<p>Open the BP<em> GazeIntoTheVoidGameMode blueprint for edit and go to the Defaults tab. Under Game Mode, change the HUD Class to BP</em> GazeIntoTheVoidHUD.</p>
<h5 id="step-3-set-up-the-level-to-use-the-specific-game-mode">Step 3: Set up the level to use the specific game mode</h5>
<p>Open the World Settings for the level (accessible via the Settings button on the toolbar), and change the Game Mode &gt; Game Mode Override to BP_ GazeIntoTheVoidGameMode.</p>
<h5 id="step-4-access-the-gaze-point-data-in-the-blueprint-graph">Step 4: Access the Gaze Point data in the blueprint graph</h5>
<p>Open the BP_GazeIntoTheVoidHUD blueprint for edit. Go to the Graph tab. Right click anywhere in the graph area and type “gazepoint” in the search box. Select the <code>Get Gaze Point</code> function under the EyeX category. Change the <code>Mode</code> parameter to <code>LightlyFiltered</code>.</p>
<p><img src="images/devguide-bp-sample-stream-get-gaze-point.png" alt=""></p>
<h5 id="step-5-draw-a-little-rectangle-at-the-gaze-point">Step 5: Draw a little rectangle at the gaze point</h5>
<p>Add a draw HUD event node, and whenever there is gaze point data available, draw a little white rectangle on the screen where the gaze point is.</p>
<p><img src="images/devguide-bp-sample-stream-draw-gaze-point.png" alt=""></p>
<h5 id="step-6-try-it-out-">Step 6: Try it out!</h5>
<p>Hit play and enjoy watching the visualization of your eye-gaze.</p>
<p><a href="#table-of-contents">&uarr; Back to Table of Contents</a></p>
<h3 id="blueprint-sample-a-cube-which-spins-when-the-player-is-looking-at-it">Blueprint sample: a cube which spins when the player is looking at it</h3>
<p>This blueprint sample will show you how to create a scene with a cube that spins when the player is looking at it.</p>
<p>Make sure you have a game project set up with the Tobii EyeX plugin. Build a Development Editor and create an empty level.</p>
<h5 id="step-1-create-the-necessary-blueprints">Step 1: Create the necessary blueprints</h5>
<p>For this sample, you need to create three blueprints: an EyeX player controller, a game mode and an EyeX actor. The EyeX player controller keeps track of which actor the player is looking at, if any. The EyeX actor can either listen to events, or read from a property to know if the player is looking at it.</p>
<p>Now, go ahead and create the three blueprints and name them like this:</p>
<ul>
<li>BP_RotateEyeXPlayerController, based on EyeXPlayerController</li><li>BP_RotateGameMode, based on GameMode</li><li>BP_RotateOnGazeCube, based on EyeXActorBase</li></ul>
<p>When creating a blueprint based on an EyeX class you need to type in the name of the EyeX specific class in the <code>All Classes</code> search box of the <code>Pick Parent Class</code> dialog, and select the class in the class hierarchy.</p>
<p><img src="images/devguide-bp-sample-cube-eyex-pc-parent-class.png" alt=""></p>
<h5 id="step-2-set-up-the-game-mode-to-use-the-specific-eyex-player-controller">Step 2: Set up the game mode to use the specific EyeX player controller</h5>
<p>Open the BP_RotateGameMode blueprint for edit and go to the Defaults tab. Under Game Mode, change the Player Controller Class to BP_RotateEyeXPlayerController.</p>
<h5 id="step-3-set-up-the-level-to-use-the-specific-game-mode">Step 3: Set up the level to use the specific game mode</h5>
<p>Open the World Settings for the level (accessible via the Settings button on the toolbar), and change the Game Mode &gt; Game Mode Override to BP_RotateGameMode.</p>
<h5 id="step-4-add-a-cube-component-to-the-eyex-actor-blueprint">Step 4: Add a cube component to the EyeX actor blueprint</h5>
<p>Open the BP_RotateOnGazeCube blueprint for edit. Go to the Components tab. Add a Static Mesh component, and change its asset to a Cube asset.</p>
<h5 id="step-5-make-the-cube-know-if-it-is-being-looked-at">Step 5: Make the cube know if it is being looked at</h5>
<p>Go to the Graph tab of the BP_RotateOnGazeCube blueprint. The cube actor can check if it is being looked at by reading the Has Gaze Focus property on every Tick event.</p>
<p><img src="images/devguide-bp-sample-cube-has-gaze-focus.png" alt=""></p>
<h5 id="step-6-make-the-cube-spin-when-it-is-being-looked-at">Step 6: Make the cube spin when it is being looked at</h5>
<p>Now, let’s make the cube spin when it is being looked at. Add a float variable called Speed and set its default value to 20.0. Then use Add Actor Local Rotation to add a yaw rotation to the cube based on the Speed and the Delta Seconds of the Tick event.</p>
<p><img src="images/devguide-bp-sample-cube-spin-at-gaze.png" alt=""></p>
<h5 id="step-7-add-some-light-and-try-it-out-">Step 7: Add some light and try it out!</h5>
<p>Go back to the level editor and add a light source in the scene so that the cube actor can be seen.</p>
<p><img src="images/devguide-bp-sample-cube-try-it.png" alt=""></p>
<p>Now, hit Play and see what happens when you are looking at the cube and when you are not looking at the cube.</p>
<h5 id="step-8-try-out-different-settings-for-the-eye-gaze-detection">Step 8: Try out different settings for the eye-gaze detection</h5>
<p>You can try out different settings for the eye-gaze detection in the EyeX player controller blueprint. Open the BP_RotateEyeXPlayerController for edit and go the the Defaults tab. Under the EyeX category, there are a number of settings that you can try and change. By checking the Visualize Detection check box a helpful debug visualization will be activated.</p>
<p><img src="images/devguide-bp-sample-cube-interaction-settings.png" alt=""></p>
<p><a href="#table-of-contents">&uarr; Back to Table of Contents</a></p>
<h2 id="building-and-distributing-your-game">Building and distributing your game</h2>
<p>When your project is finished and it is time to ship your game there are a few things to take in to consideration.</p>
<ul>
<li>The plugin currently only works for the 64-bit version of Windows so make sure you package for Windows 64-bit.</li><li>Your project has to contain code. If you’re using a blueprint-only project you will have to add code to it (File &gt; Add code to project…). It doesn’t matter what code it is, so just add an empty class. Once you’ve added some code you have to open the solution file and compile the project. The reason for this is that the Unreal Build Tool currently does not compile Plugins for blueprint-only projects. Epic Games is aware of this issue and it will probably be fixed sometime soon.</li><li>Once you’ve successfully packaged your game you need to copy the EyeX client library to the game folder. The easiest way to do that is to copy the entire EyeX client lib directory:<ul>
<li>from <code>&lt;game source dir&gt;</code>/Plugins/TobiiEyeX/ThirdParty/EyeX/lib</li><li>to <code>&lt;game output dir&gt;</code>/Plugins/TobiiEyeX/ThirdParty/EyeX/lib</li></ul>
</li></ul>
<p>The Tobii EyeX SDK license agreement gives you the permission to redistribute the client library dll with your game or application, free of charge, in most cases. The exceptions include high risk use applications, applications that might inflict on a person’s privacy, and certain other niche applications. Please see the license agreement for more details; it is available in the SDK package and it can also be downloaded from the <a href="http://developer.tobii.com">Tobii Developer Zone</a>.</p>
<p>The client library depends on the Microsoft Visual C run-time libraries, version 110, and will not work unless these libraries are installed on the computer. The run-time libraries can be downloaded free of charge from Microsoft. If you create an installer for your game, then you can add these libraries as a merge module and have them installed automatically.</p>
<p><a href="#table-of-contents">&uarr; Back to Table of Contents</a></p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
